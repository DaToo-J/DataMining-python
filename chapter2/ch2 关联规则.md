
# 二、关联规则挖掘

>想象有一堆篮子和很多产品

## 1. 频繁项集

1. 什么是：一组交易中共同出现的项目/产品组合
2. 有哪些：
    - 2-项集/配对：有2个项目的项集
    - 3-项集/三元组：有3个项目的项集


## 2. 关联规则

1. **支持度/support**：
    1. 记作：`support(X->Y) = P(X U Y)`
    2. 同时包含X和Y的篮子的百分比
    2. **最小支持阈值**：衡量项集是否为频繁项集
        - 栗子：设为5%，则如果该项集在至少5%的篮子中出现，那么该项集即为频繁项集
        
        
2. **置信度/confidence**：
        1. 记作：`confidence(X->Y) = P(Y|X) = support(X U Y) / support(X)`
        2. 已知X的情况下Y的概率
        

3. **关联规则**
        1. **先导**：规则左侧的确定项； **后继**：右侧的结果项；
        2. 栗子：`香草威化 -> 香蕉，生奶油 [支持度=1%， 置信度=40%]`
        3. 在所有篮子中，有1%的篮子包含香草威化、香蕉和生奶油的组合；在购买香草威化的客户中，有40%同时还购买了香蕉和生奶油
        

4. **附加值**
        1. 为了考虑规则之外的表现 （因为有的产品的表现好于作为关联规则后继时的表现。你本来就很美）
        2. 计算：`=规则置信度 - 右侧的支持度`
        3. 大的正数：规则是好的、有用的；
        0：规则可能是正确的，但没太大用处；
        大的负数：规则中的产品呈负相关，单飞比较好~


## 3. 寻找频繁项集
1. **向上闭包**：只有在项集的所有项目都频繁出现时，该项集才是频繁项集；这样可以减少项集数量。
2. **Apriori算法**：
        1. 设一个支持阈值
        2. 构建 1-项集 列表 `allSingletonTags`：计算每个单独项目的支持度，保留符合支持阈值的单例，存入 SingletonList
        3. 构建 2-项集 列表 `findDoubletons()`：从 SingletonList 找出所有可能的配对，保留符合支持阈值的二元组，存入 DoubletonList
        4. 构建 3-项集 列表 `findTripletons()`：从 DoubletonList 找出可能的单项，并与 DoubletonList中每个项目匹配，保留符合支持阈值的三原则，存入 TripletonList
        5. 重复重复，直到频繁项集用完
        
3. **the whole process**:
    1. `allSingletonTags`: 所有产品的集合
    2. `findDoubletons()`: 
        - 从 `allSingletonTags` 两两组合；
        - 进行数据库操作，select and count；
        - 和 `minsupport`进行比较，符合的留下来，存入`doubletonSet`(元素为二元组) / `allDoubletonTags`(元素为单项)
    3. `findTripletons()`: 
        - 从上一步得到的`allDoubletonTags`构建三元组集合；
        - 每个三元组，找出其中的3个二元组，判断二元组是否为频繁项集，即判断是否满足闭包属性；
        - 是的话，再数据库操作 select and count三元组的频次；
        - 再判断是否满足最小支持阈值；满足的话，insert 数据库。
    4. `generateRules()`: 从上一步得到的三元组集合中，生成关联规则，每个三元组可生成3个可能的规则。
    5. `calcSCAV()`: 计算每个三元组中3中可能的规则的附加值得分
    6. `compareTwoTags()`: 用来比较任意两个tag的 confidence、support ...